// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

import { MathEx } from "../utility/MathEx.sol";
import "hardhat/console.sol";

/**
 * @dev This contract contains the functions necessary to process staking rewards
 */
contract StakingRewardsMath {
    uint256 internal constant ONE = 1 << 127;

    uint256 internal constant LAMBDA_N = 142857142857143;
    uint256 internal constant LAMBDA_D = 10000000000000000000000;

    function processTokenToPoolToken(
        uint256 a_totalAmountOfTokenStaked,
        uint256 b_amountOfTokenToDistribute,
        uint256 c_totalSupplyOfPoolToken,
        uint256 d_amountOfPoolTokenOwnedByProtocol
    ) internal pure returns (uint256) {
        uint256 topFraction = b_amountOfTokenToDistribute * (c_totalSupplyOfPoolToken * c_totalSupplyOfPoolToken);
        uint256 lowerFraction = ((c_totalSupplyOfPoolToken * a_totalAmountOfTokenStaked) +
            (c_totalSupplyOfPoolToken * b_amountOfTokenToDistribute)) -
            (a_totalAmountOfTokenStaked * d_amountOfPoolTokenOwnedByProtocol);
        return MathEx.roundDiv(topFraction, lowerFraction);
    }

    function processFlatReward(
        uint256 timeElapsed, // time elapsed in the program
        uint256 totalTime, // total time of the program
        uint256 prevDistributionTime, // last distribution timestamp
        uint256 availableRewards // available rewards
    ) internal pure returns (uint256) {
        return MathEx.mulDivF(availableRewards, timeElapsed - prevDistributionTime, totalTime - prevDistributionTime);
    }

    /**
     * @dev returns the amount of rewards distributed after a given time period since deployment has elapsed
     * The returned value is calculated as `totalRewards * (1 - 1 / e ^ (LAMBDA * numOfSeconds))`.
     * Note that because the exponentiation function is limited to an input of up to (and excluding) 16, the
     * input value to this function is limited by `LAMBDA * numOfSeconds < 16` --> `numOfSeconds < 1120000000`.
     * For `numOfSeconds = 1120000000 - 1`, the formula above returns more than 99.9999% of `totalRewards`.
     */
    function processExponentialDecayReward(uint256 numOfSeconds, uint256 totalRewards) internal pure returns (uint256) {
        unchecked {
            require(numOfSeconds <= type(uint256).max / LAMBDA_N, "ERR_SECONDS_TOO_HIGH");
            uint256 n = exp(numOfSeconds * LAMBDA_N, LAMBDA_D);
            return MathEx.mulDivF(totalRewards, n - ONE, n);
        }
    }

    // prettier-ignore

    /**
     * @dev returns `e ^ (a / b) * ONE`:
     * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible
     * - The exponentiation of each binary exponent is given (pre-calculated)
     * - The exponentiation of r is calculated via Taylor series for e^x, where x = r
     * - The exponentiation of the input is calculated by multiplying the intermediate results above
     * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859
     * This function is auto-generated by 'PrintFunctionExp.py'
     */
    function exp(uint256 a, uint256 b) internal pure returns (uint256 n) { unchecked {
        uint256 x = MathEx.mulDivF(ONE, a, b);
        uint256 y;
        uint256 z;

        require(x < (ONE << 4), "ERR_EXP_VAL_TOO_HIGH");

        z = y = x % (ONE >> 3); // get the input modulo 2^(-3)
        z = z * y / ONE; n += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)
        z = z * y / ONE; n += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)
        z = z * y / ONE; n += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)
        z = z * y / ONE; n += z * 0x004807432bc18000; // add y^05 * (20! / 05!)
        z = z * y / ONE; n += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)
        z = z * y / ONE; n += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)
        z = z * y / ONE; n += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)
        z = z * y / ONE; n += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)
        z = z * y / ONE; n += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)
        z = z * y / ONE; n += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)
        z = z * y / ONE; n += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)
        z = z * y / ONE; n += z * 0x0000000017499f00; // add y^13 * (20! / 13!)
        z = z * y / ONE; n += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)
        z = z * y / ONE; n += z * 0x00000000001c6380; // add y^15 * (20! / 15!)
        z = z * y / ONE; n += z * 0x000000000001c638; // add y^16 * (20! / 16!)
        z = z * y / ONE; n += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)
        z = z * y / ONE; n += z * 0x000000000000017c; // add y^18 * (20! / 18!)
        z = z * y / ONE; n += z * 0x0000000000000014; // add y^19 * (20! / 19!)
        z = z * y / ONE; n += z * 0x0000000000000001; // add y^20 * (20! / 20!)
        n = n / 0x21c3677c82b40000 + y + ONE; // divide by 20! and then add y^1 / 1! + y^0 / 0!

        if ((x & (ONE >> 3)) != 0) n = n * 0x1c3d6a24ed82218787d624d3e5eba95f9 / 0x18ebef9eac820ae8682b9793ac6d1e776; // multiply by e^2^(-3)
        if ((x & (ONE >> 2)) != 0) n = n * 0x18ebef9eac820ae8682b9793ac6d1e778 / 0x1368b2fc6f9609fe7aceb46aa619baed4; // multiply by e^2^(-2)
        if ((x & (ONE >> 1)) != 0) n = n * 0x1368b2fc6f9609fe7aceb46aa619baed5 / 0x0bc5ab1b16779be3575bd8f0520a9f21f; // multiply by e^2^(-1)
        if ((x & (ONE << 0)) != 0) n = n * 0x0bc5ab1b16779be3575bd8f0520a9f21e / 0x0454aaa8efe072e7f6ddbab84b40a55c9; // multiply by e^2^(+0)
        if ((x & (ONE << 1)) != 0) n = n * 0x0454aaa8efe072e7f6ddbab84b40a55c5 / 0x00960aadc109e7a3bf4578099615711ea; // multiply by e^2^(+1)
        if ((x & (ONE << 2)) != 0) n = n * 0x00960aadc109e7a3bf4578099615711d7 / 0x0002bf84208204f5977f9a8cf01fdce3d; // multiply by e^2^(+2)
        if ((x & (ONE << 3)) != 0) n = n * 0x0002bf84208204f5977f9a8cf01fdc307 / 0x0000003c6ab775dd0b95b4cbee7e65d11; // multiply by e^2^(+3)
    }}
}
